<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1" />
  <title>멀티캠퍼스 러너 v21 (오류 수정 • 스폰 20%↑ • 속도 상향)</title>
  <style>
    :root{ --bg:#ffffff; --fg:#111827; --muted:#6b7280; --panel:#f8fafc; --line:#e5e7eb; --accent:#ff7a00; }
    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,"Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif;
      -webkit-tap-highlight-color:transparent;
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      overscroll-behavior:none;
    }
    .wrap{ min-height:100vh; min-height:100svh; max-width:960px; margin:0 auto; display:flex; flex-direction:column; gap:6px; padding:8px; }
    header{ display:flex; justify-content:space-between; align-items:center; gap:10px; }

    /* 로고: 이미지 링크 (반응형) */
    .logo{ display:inline-flex; align-items:center; text-decoration:none; line-height:1; }
    .logo img{
      height:clamp(22px, 3.6vw, 30px);
      width:auto; object-fit:contain; display:block;
      image-rendering:-webkit-optimize-contrast;
    }

    .hud{ display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap:6px; width:100%; }
    .pill{
      background:var(--panel); border:1px solid var(--line); border-radius:12px;
      padding:6px 8px; font-size:clamp(10px, 1.8vw, 13px); line-height:1;
      display:flex; align-items:center; justify-content:center; gap:6px; min-height:36px; white-space:nowrap;
    }
    .pill b{ font-variant-numeric: tabular-nums; }
    .pill.column{ flex-direction:column; gap:4px; }

    .life-icons{ font-size:clamp(12px, 2.2vw, 16px); line-height:1; }
    .toolbar{ display:flex; align-items:center; gap:6px; flex-wrap:nowrap; justify-content:flex-start; }
    .btn, .icon-btn{
      --h:34px; --px:10px; border:1px solid var(--line); background:#fff; color:#111827;
      padding:0 var(--px); border-radius:10px; font-weight:800; cursor:pointer;
      transition:transform .05s ease, background .2s ease;
      font-size:clamp(10px, 1.8vw, 12px); touch-action:manipulation;
      height:var(--h); display:inline-flex; align-items:center; justify-content:center; min-width:86px;
    }
    .btn:active{ transform:scale(.98); }
    .icon-btn{ min-width:40px; width:40px; padding:0; font-size:16px; }

    #gamePanel{
      width:100%; margin:0 auto; border:1px solid var(--line); border-radius:14px; overflow:hidden;
      background:#fff; box-shadow:0 6px 30px rgba(0,0,0,.06); display:flex; flex-direction:column;
    }
    #gameToolbar{ padding:6px; background:var(--bg); }
    canvas#game{ display:block; width:100%; height:auto; touch-action:none; background:linear-gradient(#f8fafc,#ffffff 45%); }

    .notice{ font-size:clamp(10px, 1.6vw, 12px); color:#6b7280; }

    dialog{ border:none; border-radius:14px; padding:0; background:#fff; color:#111827; width:min(96vw, 820px);
      box-shadow:0 22px 60px rgba(0,0,0,.2); }
    .modal{ padding:16px; }
    .modal h2{ margin:4px 0 10px; font-size:clamp(16px, 2.6vw, 18px); }
    .modal p{ margin:6px 0; color:#374151; font-size:clamp(12px, 2.2vw, 14px); line-height:1.5; }
    .modal .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:14px; }

    .char-grid{ display:grid; grid-template-columns: repeat(5, 1fr); gap:10px; margin:8px 0 4px; }
    .char{
      border:1px solid var(--line); border-radius:12px; padding:12px 6px; text-align:center; user-select:none; cursor:pointer; background:#fff;
      transition:border-color .15s ease, background .15s ease, transform .05s ease;
    }
    .char:active{ transform:scale(.98); }
    .char.sel{ border-color:#ff7a00; background:#fff7ed; }
    .char .emo{ font-size:32px; line-height:1; display:block; }

    .levels{ display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; margin:8px 0 2px; }
    .level{
      height:40px; padding:0 8px; border-radius:10px; border:1px solid var(--line); background:#fff; cursor:pointer; user-select:none;
      display:flex; align-items:center; justify-content:center; font-weight:800; font-size:14px; letter-spacing:.2px;
    }
    .level.sel{ border-color:#ff7a00; background:#fff7ed; }

    /* 순위 리스트 간단 스타일 */
    #board{ list-style:none; padding:0; margin:10px 0 0; }
    #board li{ display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px dashed #eee; }
  </style>
</head>
<body>
  <div class="wrap" id="wrapRoot">
    <header id="appHeader">
      <!-- 텍스트 → 이미지 링크 로고 (멀티캠퍼스) -->
      <a class="logo" href="https://www.multicampus.com" target="_blank" rel="noopener noreferrer" title="Multicampus 공식 사이트 이동">
        <img src="https://api.multicampus.com/ssf/v1/resource/public/images/FILBS202506207041267" alt="Multicampus" fetchpriority="high" decoding="async" />
      </a>

      <div class="hud">
        <div class="pill">점수 <b id="scoreTxt">0</b></div>
        <div class="pill">최고 <b id="bestTxt">0</b></div>
        <div class="pill">단계 <b id="stageTxt">1</b></div>
        <div class="pill column"><div>라이프</div><div class="life-icons" id="lifeTxt">♥♥♥</div></div>
      </div>
    </header>

    <div id="gamePanel">
      <div id="gameToolbar" class="toolbar">
        <div class="row">
          <button class="btn" id="playBtn" type="button">시작</button>
          <button class="btn" id="soundBtn" type="button">사운드</button>
          <button class="btn icon-btn" id="fsBtn" title="전체화면" aria-label="전체화면" type="button">⛶</button>
        </div>
      </div>
      <canvas id="game" width="600" height="960"></canvas>
    </div>

    <div class="notice" id="appNotice">
      모바일: 화면 탭=점프(즉시), 길게=조금 더 높이 / 공중에서 다시 탭=2단 점프(충돌 시 1회 추가) · 데스크톱: Space/↑ 점프
    </div>
    <!-- ★ 요청에 따라 footer 완전 제거 -->
  </div>

  <!-- 전체 스크립트 -->
  <script>
  (()=>{
    const $ = (sel)=>document.querySelector(sel);

    const wrap = $('#wrapRoot');
    const cvs = $('#game');
    const ctx = cvs.getContext('2d', { alpha:true, desynchronized:true });

    const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    let W = 600, H = 960;

    const scoreTxt=$('#scoreTxt'), bestTxt=$('#bestTxt'), stageTxt=$('#stageTxt'), lifeTxt=$('#lifeTxt');
    const playBtn=$('#playBtn'), fsBtn=$('#fsBtn'), soundBtn=$('#soundBtn');

    const startDlg=document.createElement('dialog'); startDlg.id='startDlg';
    startDlg.innerHTML = `
      <div class="modal">
        <h2>캐릭터 & 단계 선택</h2>
        <div class="char-grid" id="charGrid" role="listbox" aria-label="캐릭터 선택"></div>
        <p style="margin:6px 0 2px;">단계 선택</p>
        <div class="levels" id="levels">
          <div class="level sel" data-stage="1">1단계</div>
          <div class="level" data-stage="2">2단계</div>
          <div class="level" data-stage="3">3단계</div>
        </div>
        <div class="actions">
          <button class="btn" id="startOk" type="button">시작</button>
        </div>
      </div>`;
    wrap.appendChild(startDlg);

    const overDlg=document.createElement('dialog'); overDlg.id='overDlg';
    overDlg.innerHTML = `
      <div class="modal">
        <h2>게임 종료</h2>
        <p>점수: <b id="finalScore">0</b></p>
        <div id="nameWrap">
          <p>순위표에 이름을 남겨요:</p>
          <input type="text" id="playerName" placeholder="이름(최대 12자)" maxlength="12"/>
        </div>
        <ul class="list" id="board"></ul>
        <div class="actions">
          <button class="btn" id="saveBtn" type="button">저장</button>
          <button class="btn" id="againBtn" type="button">다시 플레이</button>
        </div>
      </div>`;
    wrap.appendChild(overDlg);

    const startOk = startDlg.querySelector('#startOk');
    const againBtn = overDlg.querySelector('#againBtn');
    const boardUl = overDlg.querySelector('#board');
    const finalScore = overDlg.querySelector('#finalScore');
    const playerName = overDlg.querySelector('#playerName');
    const saveBtn = overDlg.querySelector('#saveBtn');
    const levelWrapRef = () => document.querySelector('#levels');
    const charGridRef = () => document.querySelector('#charGrid');

    // dialog 폴리필 (iOS, 일부 안드로이드/데스크탑 구형)
    const supportsDialog = typeof HTMLDialogElement !== 'undefined' && !!HTMLDialogElement.prototype.showModal;
    function ensureDialogPolyfill(dlg){
      if(!supportsDialog){
        if(!dlg.showModal){
          dlg.showModal = function(){ this.setAttribute('open',''); this.style.display='block'; document.documentElement.style.overflow='hidden'; };
        }
        if(!dlg.close){
          dlg.close = function(){ this.removeAttribute('open'); this.style.display='none'; document.documentElement.style.overflow=''; };
        }
      }
    }
    ensureDialogPolyfill(startDlg);
    ensureDialogPolyfill(overDlg);

    // 캐릭터 목록
    const CHAR_LIST=[
      ['dog','강아지','🐕'],
      ['cat','고양이','🐈'],
      ['rabbit','토끼','🐇'],
      ['puffer','복어','🐡'],
      ['squirrel','다람쥐','🐿️']
    ];
    let selected = localStorage.getItem('mc_char_v21') || 'dog';
    let stage = Number(localStorage.getItem('mc_stage_v21') || '1');

    // 오디오 (사용자 제스처 언락 필요)
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audioCtx = AudioCtx ? new AudioCtx() : null;
    let soundOn = true, audioUnlocked = false;
    function unlockAudio(){
      if(!audioCtx || audioUnlocked) return;
      try{
        const b=audioCtx.createBuffer(1,1,22050);
        const s=audioCtx.createBufferSource();
        s.buffer=b; s.connect(audioCtx.destination); s.start(0);
        audioUnlocked = true;
      }catch(e){ /* ignore */ }
    }
    function beep(freq=600,dur=0.06,type='square',vol=0.08){
      if(!soundOn || !audioUnlocked || !audioCtx) return;
      const o=audioCtx.createOscillator();
      const g=audioCtx.createGain();
      o.type=type; o.frequency.value=freq; g.gain.value=vol;
      o.connect(g).connect(audioCtx.destination); o.start();
      setTimeout(()=>{ try{o.stop()}catch(e){} }, Math.max(1, dur*1000|0));
    }

    const state={running:false,over:false};
    let score=0, best=Number(localStorage.getItem('mc_best_v21')||0);
    scoreTxt.textContent='0'; bestTxt.textContent=String(best);

    const GROUND_Y = () => Math.floor(H*0.86);
    const gravityBase = 0.0022;
    let speed = 0.35;
    let timeSinceStart = 0;

    let livesMax=3, lives=3;
    let invincibleMs=0;
    let bonusJumpAvailable=false;
    const items=[];

    const hero={
      x:()=> Math.round(W*0.18),
      y: 0, vy:0, w:28, h:28, onGround:false, jumps:0,
      draw(){ drawHero(this.x(), Math.round(this.y), this.w, this.h); },
      aabb(){ return { x:this.x()- (this.w/2|0), y:(this.y-(this.h/2)|0), w:this.w|0, h:this.h|0 }; }
    };
    const obstacles=[];

    const LEVELS={
      1:{ speedBase:.30, rampLow:.000035, rampMed:.000065, rampHigh:.00010, segMs:[18000,42000],
          spawnMin:720*0.8, spawnMax:1150*0.8, mix:{block:.6,rolling:.25,tall:.15}, itemCooldown:5000, itemChance:.30, factor:1.00 },
      2:{ speedBase:.34, rampLow:.00005, rampMed:.000085, rampHigh:.00013, segMs:[16000,38000],
          spawnMin:630*0.8, spawnMax:1020*0.8, mix:{block:.35,rolling:.25,tall:.15,flying:.15,stack:.10}, itemCooldown:5600, itemChance:.30, factor:1.04 },
      3:{ speedBase:.38, rampLow:.00007, rampMed:.00011, rampHigh:.00016, segMs:[14000,34000],
          spawnMin:560*0.8, spawnMax:940*0.8, mix:{block:.20,rolling:.25,tall:.15,flying:.20,stack:.20}, itemCooldown:6000, itemChance:.30, factor:1.08 }
    };
    let config = LEVELS[stage] || LEVELS[1];

    function piecewiseSpeed(t, lv){
      const ms1 = lv.segMs[0], ms2 = lv.segMs[1];
      const low = Math.min(t, ms1) * lv.rampLow;
      const med = Math.max(0, Math.min(t - ms1, ms2 - ms1)) * lv.rampMed;
      const high = Math.max(0, t - ms2) * lv.rampHigh;
      const cap = 0.62;
      return (lv.speedBase + Math.min(cap, (low+med+high))) * (lv.factor||1);
    }

    function chooseType(){
      const m=config.mix, r=Math.random(); let a=0;
      for(const [k,v] of Object.entries(m)){ a+=v; if(r<=a) return k; }
      return 'block';
    }

    function fitToBox(boxW, boxH, ratioW, ratioH){
      const target = ratioW/ratioH, box = boxW/boxH;
      let w,h;
      if(box >= target){ h = Math.floor(boxH); w = Math.floor(h * target); }
      else{ w = Math.floor(boxW); h = Math.floor(w / target); }
      return [w,h];
    }
    function computeAvail(){
      const wrapRect = wrap.getBoundingClientRect();
      const wrapH = Math.max(320, Math.floor(wrapRect.height));
      const wrapW = Math.floor(wrapRect.width);
      const head = $('#appHeader')?.offsetHeight || 0;
      const tool = $('#gameToolbar')?.offsetHeight || 0;
      const notice = $('#appNotice')?.offsetHeight || 0;
      const vPad = 12;
      const availW = Math.max(320, Math.min(($('#gamePanel')?.getBoundingClientRect().width||wrapW), wrapW));
      const availH = Math.max(360, Math.floor(wrapH - head - tool - notice - vPad));
      return {availW, availH};
    }
    function resize(){
      const {availW, availH} = computeAvail();
      const [w,h] = fitToBox(availW, availH, 10, 16);
      W=Math.max(280, w); H=Math.max(360, h);
      cvs.style.width=W+'px'; cvs.style.height=H+'px';
      cvs.width=(W*DPR)|0; cvs.height=(H*DPR)|0;
      ctx.setTransform(DPR,0,0,DPR,0,0);
      ctx.imageSmoothingEnabled=false;
      hero.vy=0; hero.onGround=true; hero.y=GROUND_Y();
      draw();
    }
    addEventListener('resize', resize, {passive:true});
    if(window.visualViewport){
      window.visualViewport.addEventListener('resize', ()=> setTimeout(resize, 16), {passive:true});
      window.visualViewport.addEventListener('scroll', ()=> setTimeout(resize, 16), {passive:true});
    }

    const rand=(a,b)=> a + Math.random()*(b-a);
    function roundRect(c,x,y,w,h,r){
      x=Math.round(x)+0.5; y=Math.round(y)+0.5; w=Math.round(w); h=Math.round(h);
      c.beginPath();
      c.moveTo(x+r,y);
      c.arcTo(x+w,y,x+w,y+h,r);
      c.arcTo(x+w,y+h,x,y+h,r);
      c.arcTo(x,y+h,x,y,r);
      c.arcTo(x,y,x+w,y,r);
      c.closePath();
    }
    function rectHit(ax,ay,aw,ah,bx,by,bw,bh){
      return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
    }

    function drawHero(cx, cy, w, h){
      const map = Object.fromEntries(CHAR_LIST.map(([k,_n,e])=>[k,e]));
      const emoji = map[selected] || '🐕';
      const size = Math.max(w, h) * 1.05;
      ctx.save();
      ctx.translate(cx, 0);
      ctx.scale(-1, 1); // 오른쪽 향하게 (입체감)
      ctx.font = `${Math.floor(size)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",system-ui,sans-serif`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(emoji, 0, Math.round(cy)-1);
      ctx.restore();
    }

    // UI 빌드: 캐릭터 / 레벨 (중복 정의 방지)
    function buildCharGrid(){
      const charGrid = charGridRef();
      if(!charGrid) return;
      charGrid.innerHTML='';
      CHAR_LIST.forEach(([key,_label,emo])=>{
        const cell=document.createElement('div');
        cell.className='char'+(key===selected?' sel':'');
        cell.dataset.type=key;
        const span=document.createElement('span'); span.className='emo'; span.textContent=emo;
        cell.appendChild(span);
        charGrid.appendChild(cell);
      });
    }

    // 점프(2단) + 공중 충돌 보너스 1회
    let holding=false, holdBoostTimer=null;
    function doJump(){
      if(!state.running) return;
      if(hero.jumps < 2){
        const first = hero.jumps===0;
        const k = 1.105;
        const v1 = (-0.74 * 0.72) * k;
        const v2 = (-0.65 * 0.72) * k;
        hero.vy = first ? v1 : v2;
        hero.jumps++; hero.onGround=false;
        beep(first?700:620, .05);
      } else if (bonusJumpAvailable) {
        const v3 = (-0.60 * 0.72) * 1.05;
        hero.vy = v3;
        bonusJumpAvailable = false;
        beep(580, .05, 'triangle', .09);
      }
    }
    function onPointerDown(e){
      unlockAudio(); holding=true; doJump();
      if(holdBoostTimer) clearInterval(holdBoostTimer);
      holdBoostTimer = setInterval(()=>{ if(!holding) return; if(hero.vy < -0.05) hero.vy *= 0.99; }, 16);
      e.preventDefault();
    }
    function onPointerUp(e){
      holding=false;
      if(holdBoostTimer){ clearInterval(holdBoostTimer); holdBoostTimer=null; }
      e.preventDefault();
    }
    cvs.addEventListener('pointerdown', onPointerDown, {passive:false});
    addEventListener('pointerup', onPointerUp, {passive:false});
    addEventListener('keydown', e=>{
      if(e.code==='Space'||e.code==='ArrowUp'){
        e.preventDefault(); unlockAudio(); doJump();
      }
    }, {passive:false});
    // 러닝 중 스크롤 방지 (iOS 사파리 포함)
    document.addEventListener('touchmove', (e)=>{ if(state.running){ e.preventDefault(); } }, {passive:false});

    // 루프
    let last=0, acc=0; const stepMs=1000/60;
    function loop(t){
      requestAnimationFrame(loop);
      if(!last) last=t;
      let dt=t-last; last=t;
      dt=Math.min(dt,48);
      acc+=dt;
      while(acc>=stepMs){
        if(state.running) update(stepMs);
        acc-=stepMs;
      }
      draw();
    }
    requestAnimationFrame(loop);

    const obstaclesConf={ t:0 }, itemT={ t:0 };
    function chooseSpawnInterval(){ return Math.max(config.spawnMin, config.spawnMax - timeSinceStart*0.10); }
    function spawnObstacle(){
      const type = chooseType();
      const gy = GROUND_Y();
      const thick = 3;
      if(type==='block'){
        const h = Math.round(rand(H*0.035, H*0.06)), w = Math.round(rand(14, 26));
        obstacles.push({kind:'block', x:W+40, y:gy-1, w, h, passed:false, thick});
      }else if(type==='rolling'){
        const s = Math.round(rand(12, 20));
        obstacles.push({kind:'rolling', x:W+40, y:gy-1, w:s, h:s, rot:0, passed:false, thick});
      }else if(type==='tall'){
        const h = Math.round(rand(H*0.09, H*0.14)), w = Math.round(rand(11, 15));
        obstacles.push({kind:'tall', x:W+40, y:gy-1, w, h, passed:false, thick});
      }else if(type==='flying'){
        const h = Math.round(rand(H*0.035, H*0.06)), w = Math.round(rand(11, 16));
        const y = Math.round(gy - rand(H*0.18, H*0.27));
        obstacles.push({kind:'flying', x:W+40, y, w, h, passed:false, thick});
      }else if(type==='stack'){
        const h1 = Math.round(rand(H*0.035, H*0.06)), h2 = Math.round(rand(H*0.035, H*0.06));
        const w = Math.round(rand(11, 16)); const x0=W+40;
        obstacles.push({kind:'block', x:x0, y:GROUND_Y()-1, w, h:h1, passed:false, thick});
        obstacles.push({kind:'block', x:x0 + Math.round(rand(18, 24)), y:GROUND_Y()-1, w, h:h2, passed:false, pair:true, thick});
      }
    }
    function spawnItem(){
      const gy = GROUND_Y();
      const r = Math.random();
      if(r < 0.5){
        const s=18; items.push({kind:'life', x:W+50, y:gy - s, w:s, h:s});
      }else{
        const s=18; const y = Math.round(gy - rand(H*0.20, H*0.32));
        items.push({kind:'shield', x:W+50, y, w:s, h:s});
      }
    }

    function update(dt){
      timeSinceStart += dt;
      const gy = GROUND_Y();
      const gravity = gravityBase * H;
      if(invincibleMs>0){ invincibleMs = Math.max(0, invincibleMs - dt); }

      speed = piecewiseSpeed(timeSinceStart, config);

      obstaclesConf.t += dt; itemT.t += dt;
      if(obstaclesConf.t > chooseSpawnInterval()){ obstaclesConf.t = 0; spawnObstacle(); }
      if(itemT.t > config.itemCooldown){ itemT.t = 0; if(Math.random() < config.itemChance) spawnItem(); }

      hero.vy += gravity * (dt/1000);
      hero.y += hero.vy * (dt/1);
      if(hero.y > gy){
        hero.y = gy; hero.vy=0;
        if(!hero.onGround){ hero.jumps=0; bonusJumpAvailable=false; }
        hero.onGround=true;
      } else { hero.onGround=false; }
      if(hero.y < 0) hero.y = 0;

      for(const ob of obstacles){
        ob.x -= speed * dt;
        if(ob.kind==='rolling') ob.rot = (ob.rot||0) + 0.005*dt;
        if(!ob.passed && ob.x + ob.w < hero.x()){
          ob.passed = true; score += 1; scoreTxt.textContent = String(score);
        }
      }
      while(obstacles.length && obstacles[0].x+obstacles[0].w < -10){ obstacles.shift(); }

      for(const it of items){ it.x -= speed * dt; }
      while(items.length && items[0].x+items[0].w < -10){ items.shift(); }

      const h = hero.aabb();
      for(let i=items.length-1;i>=0;i--){
        const it = items[i];
        if(rectHit(h.x,h.y,h.w,h.h, Math.round(it.x), Math.round(it.y), it.w, it.h)){
          if(it.kind==='life' && lives < livesMax){ lives++; beep(880,.08,'triangle',.12); }
          if(it.kind==='shield'){ invincibleMs = 3500; beep(520,.10,'sawtooth',.12); }
          items.splice(i,1);
        }
      }
      if(invincibleMs<=0){
        for(const ob of obstacles){
          const oy = (ob.kind==='flying') ? ob.y : (ob.y - ob.h);
          if(rectHit(h.x,h.y,h.w,h.h, Math.round(ob.x), oy, ob.w, ob.h)){
            lives--; invincibleMs = 1100;
            if(hero.y < gy && lives > 0){ bonusJumpAvailable = true; }
            if(lives<=0){ return gameOver(); }
            break;
          }
        }
      }

      lifeTxt.textContent='♥'.repeat(lives)+'♡'.repeat(livesMax-lives);
    }

    function draw(){
      const grd=ctx.createLinearGradient(0,0,0,H);
      grd.addColorStop(0,'#f8fafc'); grd.addColorStop(1,'#ffffff');
      ctx.fillStyle=grd; ctx.fillRect(0,0,W,H);
      const gy=GROUND_Y();
      ctx.fillStyle='#f3f4f6'; ctx.fillRect(0,gy,W,H-gy);
      const off=Math.round((performance.now()*0.12)%(22));
      ctx.fillStyle='#e5e7eb';
      for(let x=-off;x<W;x+=22){ ctx.fillRect(x, gy+5, 12, 2); }

      hero.draw();

      // 장애물
      for(const ob of obstacles){
        ctx.save();
        ctx.lineWidth=ob.thick||3; ctx.strokeStyle='rgba(185,28,28,0.9)'; ctx.fillStyle='#ef4444';
        if(ob.kind==='rolling'){
          ctx.translate(Math.round(ob.x+ob.w/2), Math.round(ob.y-ob.h/2)); ctx.rotate(ob.rot||0);
          roundRect(ctx, -ob.w/2, -ob.h/2, ob.w, ob.h, 6); ctx.fill(); ctx.stroke();
        }else{
          roundRect(ctx, Math.round(ob.x), Math.round(ob.y-ob.h), Math.round(ob.w), Math.round(ob.h), 6); ctx.fill(); ctx.stroke();
        }
        ctx.restore();
      }

      // 아이템
      ctx.font = `46px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",system-ui,sans-serif`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      for(const it of items){
        ctx.fillText(it.kind==='life' ? '♥' : '🛡️', Math.round(it.x+it.w/2), Math.round(it.y+it.h/2+1));
      }
    }

    function startGame(){
      state.over=false; state.running=true;
      playBtn.disabled=true;
      score=0; scoreTxt.textContent='0';
      timeSinceStart=0; obstacles.length=0; items.length=0;
      lives=3; invincibleMs=0; bonusJumpAvailable=false;
      hero.y = GROUND_Y(); hero.vy=0; hero.onGround=true; hero.jumps=0;
      config = LEVELS[stage] || LEVELS[1];
      stageTxt.textContent = String(stage);
      localStorage.setItem('mc_char_v21', selected);
      localStorage.setItem('mc_stage_v21', String(stage));
      beep(520,.05);
    }
    function gameOver(){
      if(state.over) return;
      state.over=true; state.running=false;
      playBtn.disabled=false;
      finalScore.textContent = String(score);
      if(score>best){ best=score; localStorage.setItem('mc_best_v21', String(best)); bestTxt.textContent=String(best); }
      renderBoard(); overDlg.showModal(); setTimeout(()=>{ playerName?.focus(); }, 50);
    }

    function renderBoard(){
      const arr = JSON.parse(localStorage.getItem('mc_board_v21')||'[]');
      boardUl.innerHTML='';
      if(!arr.length){
        const li=document.createElement('li'); li.innerHTML='<span>등록된 기록이 없습니다.</span><span>—</span>';
        boardUl.appendChild(li); return;
      }
      arr.slice(0,10).forEach((it,idx)=>{
        const li=document.createElement('li');
        li.innerHTML=`<span>${idx+1}. ${it.name} (${it.stage}단계)</span><span>${it.score}</span>`;
        boardUl.appendChild(li);
      });
    }

    function saveRecord(){
      const name = (playerName.value||'플레이어').trim().slice(0,12);
      const arr = JSON.parse(localStorage.getItem('mc_board_v21')||'[]');
      arr.push({name, score, stage, t:Date.now()});
      arr.sort((a,b)=> b.score - a.score || a.t - b.t);
      localStorage.setItem('mc_board_v21', JSON.stringify(arr));
      renderBoard();
    }

    // 이벤트 바인딩
    function onCharClick(e){
      const cell = e.target.closest('.char'); if(!cell) return;
      selected = cell.dataset.type;
      localStorage.setItem('mc_char_v21', selected);
      charGridRef().querySelectorAll('.char').forEach(el=> el.classList.toggle('sel', el===cell));
    }

    function bindUI(){
      // 캐릭터/레벨 선택 UI
      charGridRef().addEventListener('click', onCharClick);
      levelWrapRef().addEventListener('click', (e)=>{
        const btn = e.target.closest('.level'); if(!btn) return;
        stage = Number(btn.dataset.stage)||1;
        localStorage.setItem('mc_stage_v21', String(stage));
        levelWrapRef().querySelectorAll('.level').forEach(el=> el.classList.toggle('sel', el===btn));
        stageTxt.textContent = String(stage);
        config = LEVELS[stage] || LEVELS[1];
      });

      playBtn.addEventListener('click', ()=>{ buildCharGrid(); startDlg.showModal(); });
      startOk.addEventListener('click', ()=>{
        startDlg.close();
        // 안내는 alert 대신 음으로 대체(모바일 키보드 포커스 방해 방지)
        beep(760,.06,'sine',.06);
        startGame();
      });

      fsBtn.addEventListener('click', ()=>{
        const elem=document.documentElement;
        try{
          if(!document.fullscreenElement){
            (elem.requestFullscreen && elem.requestFullscreen())
            || (elem.webkitRequestFullscreen && elem.webkitRequestFullscreen());
          }else{
            document.exitFullscreen && document.exitFullscreen();
          }
        }catch(e){ /* iOS Safari 등에서 무시 */ }
      });

      soundBtn.addEventListener('click', ()=>{
        soundOn = !soundOn;
        soundBtn.textContent = soundOn ? '사운드' : '무음';
        if(soundOn){ unlockAudio(); beep(700,.05,'sine',.08); }
      });

      [startDlg, overDlg].forEach(d=>{
        d.addEventListener('cancel', e=> e.preventDefault());
        d.addEventListener('click', e=>{
          const rect = d.getBoundingClientRect();
          if(e.clientX<rect.left || e.clientX>rect.right || e.clientY>rect.bottom || e.clientY<rect.top){ e.preventDefault(); }
        });
      });

      againBtn.addEventListener('click', ()=>{ overDlg.close(); startDlg.showModal(); });
      saveBtn.addEventListener('click', ()=> saveRecord());
    }

    // 초기 페인트
    function firstPaint(){
      buildCharGrid();
      const prevLvl = levelWrapRef().querySelector(`[data-stage="${stage}"]`) || levelWrapRef().firstElementChild;
      if(prevLvl){ levelWrapRef().querySelectorAll('.level').forEach(el=> el.classList.toggle('sel', el===prevLvl)); }
      stageTxt.textContent = String(stage);
      lives=3; lifeTxt.textContent='♥♥♥';
      hero.y = GROUND_Y(); hero.onGround=true; hero.jumps=0; draw();
      resize();
      startDlg.showModal();
    }

    bindUI();
    firstPaint();

  })();
  </script>
</body>
</html>