<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
  <title>ë‚ ì•„ë¼ ë©€ìº ëŸ¬</title>
  <!-- íŒŒë¹„ì½˜: ì£¼í™©ìƒ‰ ë™ê·¸ë¼ë¯¸ -->
  <link rel="icon" type="image/svg+xml"
        href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><circle cx="32" cy="32" r="28" fill="%23ff7a17"/></svg>'>
  <meta name="theme-color" content="#ffffff" />
  <style>
    :root{
      --bg:#ffffff; --panel:#ffffff; --text:#0e1220; --accent:#ff7a17;
      --muted:#6b7280; --line:#e9edf3; --shadow:rgba(0,0,0,0.06);
      --logo: clamp(56px, 8vw, 96px);
    }
    *{box-sizing:border-box}
    html,body{
      height:100%; margin:0; background:var(--bg); color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, "Noto Sans KR", "ë§‘ì€ ê³ ë”•", sans-serif;
      -webkit-tap-highlight-color: transparent;
    }
    body, button { touch-action: manipulation; user-select: none; -webkit-user-select: none; }
    #gameWrap{
      position:relative;width:100%;
      height:calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      padding-top:env(safe-area-inset-top); padding-bottom:env(safe-area-inset-bottom);
      overflow:hidden; background:var(--bg);
    }
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;background:#ffffff;}
    .mc-logo-img{
      position:absolute; left:12px; top: calc(env(safe-area-inset-top) + 10px);
      z-index:20; width:var(--logo); height:var(--logo); object-fit:contain; -webkit-user-drag:none; pointer-events:none;
    }
    /* HUD: ë¼ì´í”„/ì ìˆ˜ë§Œ í‘œì‹œ */
    .cornerHUD{
      position:absolute; left:12px; top:calc(var(--logo) + 24px);
      z-index:8; display:flex; flex-direction:column; gap:6px;
      background:rgba(255,255,255,0.88); padding:8px 10px; border-radius:10px; border:1px solid var(--line);
      backdrop-filter: blur(4px); font-weight:700;
    }
    .lifeRow{ display:flex; align-items:center; gap:6px; }
    .heart{ font-size:18px; line-height:1; }
    .scoreLabel{ font-weight:800; }

    .soundToggle{
      position:absolute; right:12px; top: calc(env(safe-area-inset-top) + 10px);
      z-index:20; background:rgba(255,255,255,0.88); border:1px solid var(--line); border-radius:999px;
      padding:6px 12px; font-weight:800; display:inline-flex; align-items:center; gap:8px; backdrop-filter: blur(4px);
    }
    .soundToggle button{ background:none; border:none; font:inherit; cursor:pointer; }
    .soundToggle .icon{font-size:18px}

    .overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(255,255,255,0.75); padding:clamp(12px, 3vw, 24px); z-index:6;
      -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px);
    }
    .panel{
      width:min(760px,94vw); background:var(--panel); border:1px solid var(--line);
      border-radius:16px; padding:clamp(14px, 2.8vw, 22px); box-shadow:0 10px 24px var(--shadow);
    }
    .title{font-weight:800; font-size: clamp(20px, 5.2vw, 34px); line-height:1.2; margin:4px 0 8px;}
    .subtitle{color:var(--muted); margin:0 0 14px; font-size:clamp(12px, 3.4vw, 14px)}
    .btn{appearance:none; border:1px solid var(--line); background:#fff; color:#0b1020;
      padding:12px 16px; border-radius:12px; cursor:pointer; font-weight:800; transition:.15s;
      box-shadow:0 2px 6px var(--shadow); font-size:clamp(14px, 3.6vw, 16px);}
    .btn.primary{background:var(--accent); border-color:#ef6b05; color:#111;}
    .btn:active{transform: translateY(1px)}
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game" aria-label="ê²Œì„ ìº”ë²„ìŠ¤" role="img"></canvas>

    <img class="mc-logo-img" alt="multicampus"
         decoding="async" fetchpriority="high"
         src="https://api.multicampus.com/ssf/v1/resource/public/images/FILBS202506207041267"/>

    <div class="soundToggle"><span class="icon" id="soundIcon">ğŸ”Š</span><button id="btnSound" aria-pressed="false">ì‚¬ìš´ë“œ ON</button></div>

    <!-- HUD -->
    <div class="cornerHUD" id="hud" style="display:none">
      <div class="lifeRow" id="lifeRow" aria-label="ë‚¨ì€ ëª©ìˆ¨"></div>
      <div class="scoreLabel">ì ìˆ˜ <b id="hudScore">0</b></div>
    </div>

    <!-- Start Screen -->
    <div class="overlay" id="startScreen" aria-modal="true">
      <div class="panel">
        <div class="title">ë‚ ì•„ë¼ ë©€ìº ëŸ¬!</div>
        <p class="subtitle">ì¥ì• ë¬¼ í”¼í•´ ë©€ë¦¬ ë‹¬ë ¤ë³´ì„¸ìš” ğŸš€</p>
        <button class="btn primary" id="btnStart">ê²Œì„ ì‹œì‘</button>
      </div>
    </div>

    <!-- Game Over -->
    <div class="overlay" id="gameOverScreen" style="display:none" aria-modal="true">
      <div class="panel">
        <div class="title">ê²Œì„ ì¢…ë£Œ</div>
        <div><span id="finalScore">0</span> ì </div>
        <button class="btn" id="btnRetry">ë‹¤ì‹œ í•˜ê¸°</button>
        <button class="btn" id="btnGoHome">ì²˜ìŒìœ¼ë¡œ</button>
      </div>
    </div>
  </div>

  <script>
    // ===== ê¸°ë³¸ ì„¸íŒ… =====
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d", { alpha: true, desynchronized: true });
    let W=0, H=0, DPR=Math.min(window.devicePixelRatio||1, 2);

    function applyCanvasSize() {
      const cw = Math.floor(canvas.clientWidth);
      const ch = Math.floor(canvas.clientHeight);
      W = cw; H = ch;
      canvas.width  = Math.max(1, Math.floor(cw * DPR));
      canvas.height = Math.max(1, Math.floor(ch * DPR));
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      ctx.textBaseline = "alphabetic";
    }
    new ResizeObserver(applyCanvasSize).observe(canvas); applyCanvasSize();

    const groundY = () => H - 50;

    // ===== ê²Œì„ ìƒíƒœ =====
    let running=false, score=0;
    let lives=3, maxLives=5;
    const hud = document.getElementById("hud");
    const hudScore = document.getElementById("hudScore");
    const lifeRow = document.getElementById("lifeRow");
    const startScreen = document.getElementById("startScreen");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const finalScore = document.getElementById("finalScore");

    document.getElementById("btnStart").addEventListener("click", startGame, {passive:true});
    document.getElementById("btnRetry").addEventListener("click", startGame, {passive:true});
    document.getElementById("btnGoHome").addEventListener("click", ()=> {
      startScreen.style.display="flex"; gameOverScreen.style.display="none";
    }, {passive:true});

    // ì‚¬ìš´ë“œ í† ê¸€(í›„ì† í™•ì¥ìš©)
    const btnSound = document.getElementById("btnSound");
    const soundIcon = document.getElementById("soundIcon");
    let soundOn = true;
    btnSound.addEventListener("click", ()=>{
      soundOn = !soundOn;
      btnSound.textContent = soundOn ? "ì‚¬ìš´ë“œ ON" : "ì‚¬ìš´ë“œ OFF";
      btnSound.setAttribute("aria-pressed", String(soundOn));
      soundIcon.textContent = soundOn ? "ğŸ”Š" : "ğŸ”‡";
    }, {passive:true});

    // ===== í”Œë ˆì´ì–´(ì´ëª¨ì§€, ì˜¤ë¥¸ìª½ ë³´ê²Œ ë°˜ì „) & ì í”„ =====
    const EMOJI = "ğŸ–"; // ê¸°ë³¸ ì¢Œí–¥ -> ë°˜ì „ ë Œë”
    const EMOJI_FONT = "28px Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, emoji";
    const pig = { x: 100, y: 0, vy: 0, onGround: true, jumpCount: 0, maxJump: 2, invUntil: 0, blink: false };

    function drawEmojiFacingRight(text, x, y, alpha=1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.font = EMOJI_FONT;
      const w = Math.max(24, ctx.measureText(text).width);
      ctx.translate(x + w, 0);
      ctx.scale(-1, 1);
      ctx.fillText(text, 0, y);
      ctx.restore();
    }

    function updateLivesHUD() {
      lifeRow.innerHTML = "";
      for (let i=0;i<lives;i++){
        const span = document.createElement("span");
        span.className = "heart";
        span.textContent = "â¤ï¸";
        lifeRow.appendChild(span);
      }
      if (lives === 0) {
        const span = document.createElement("span");
        span.className = "heart";
        span.textContent = "ğŸ–¤";
        lifeRow.appendChild(span);
      }
    }

    function jump(){
      if (!running) return;
      if (pig.jumpCount < pig.maxJump) {
        pig.vy = -12;
        pig.onGround = false;
        pig.jumpCount++;
      }
    }
    window.addEventListener("keydown", (e)=>{
      if (e.code === "Space" || e.code === "ArrowUp") { e.preventDefault(); jump(); }
    }, { passive:false });
    canvas.addEventListener("pointerdown", ()=> jump(), { passive:true });

    // ===== ì¥ì• ë¬¼(ëœë¤ ëª¨ì–‘) =====
    const obstacles = [];
    let spawnTimer = 0;
    let baseSpeed = 3;

    // shape: 'rect' | 'circle' | 'tri'
    function spawnObstacle() {
      const shapeTypes = ["rect", "circle", "tri"];
      const shape = shapeTypes[(Math.random() * shapeTypes.length) | 0];

      // í¬ê¸° ëœë¤
      const sizeA = 24 + Math.random()*40; // í­/ì§€ë¦„/ë°‘ë³€ ë“±
      const sizeB = 24 + Math.random()*40; // ë†’ì´(ì‚¬ê°/ì‚¼ê°)
      const color = "#ff7a17";

      const yTop = groundY() - Math.max(sizeA, sizeB) - (shape==="circle" ? 0 : 0);

      obstacles.push({
        shape,
        x: W + 30,
        y: shape === "circle" ? groundY() - sizeA/2 - 2 : groundY() - sizeB, // ì›ì€ ì¤‘ì‹¬ y ì‚¬ìš©
        w: sizeA,
        h: sizeB,
        r: sizeA/2, // circle radius
        color
      });
    }

    function updateObstacles() {
      const speed = baseSpeed + Math.min(6, score/150);
      for (const o of obstacles) o.x -= speed;
      for (let i=obstacles.length-1;i>=0;i--){
        if (obstacles[i].x + (obstacles[i].w || obstacles[i].r*2) < -60) obstacles.splice(i,1);
      }
      if (spawnTimer <= 0) {
        spawnObstacle();
        spawnTimer = 50 + Math.random()*55; // 0.9~1.75ì´ˆ ì •ë„
      } else spawnTimer--;
    }

    function drawObstacles() {
      ctx.lineWidth = 2;
      for (const o of obstacles) {
        ctx.fillStyle = o.color;
        ctx.strokeStyle = "#e35f00";
        if (o.shape === "rect") {
          ctx.fillRect(o.x, o.y, o.w, o.h);
          ctx.strokeRect(o.x, o.y, o.w, o.h);
        } else if (o.shape === "circle") {
          ctx.beginPath();
          ctx.arc(o.x, o.y, o.r, 0, Math.PI*2);
          ctx.fill(); ctx.stroke();
        } else if (o.shape === "tri") {
          const base = o.w, height = o.h;
          ctx.beginPath();
          // ë°‘ë³€ì€ ë°”ë‹¥ê³¼ í‰í–‰, ê¼­ì§“ì  ìœ„
          const x1 = o.x, x2 = o.x + base, x3 = o.x + base/2;
          const yBase = groundY();
          ctx.moveTo(x1, yBase);
          ctx.lineTo(x2, yBase);
          ctx.lineTo(x3, yBase - height);
          ctx.closePath();
          ctx.fill(); ctx.stroke();
          // triì˜ ì¶©ëŒìš© AABB ë³´ì •ìš© ê°’ ì €ì¥
          o._aabb = { x: Math.min(x1,x2,x3), y: yBase - height, w: base, h: height };
        }
      }
    }

    function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    function checkCollision() {
      // ìºë¦­í„° íˆíŠ¸ë°•ìŠ¤(ì´ëª¨ì§€ ì£¼ë³€ ì‚¬ê°í˜•)
      const box = { x: pig.x-8, y: pig.y-24, w: 28, h: 26 };

      for (const o of obstacles) {
        if (o.shape === "rect") {
          if (rectsOverlap(box.x,box.y,box.w,box.h, o.x,o.y,o.w,o.h)) return true;
        } else if (o.shape === "circle") {
          // ì›-ì‚¬ê° ì¶©ëŒ
          const nx = Math.max(o.x - o.r, Math.min(box.x + box.w, o.x + o.r));
          const ny = Math.max(o.y - o.r, Math.min(box.y + box.h, o.y + o.r));
          const dx = nx - o.x, dy = ny - o.y;
          if (dx*dx + dy*dy <= o.r*o.r) return true;
        } else if (o.shape === "tri") {
          const a = o._aabb || { x:o.x, y:o.y, w:o.w, h:o.h };
          if (rectsOverlap(box.x,box.y,box.w,box.h, a.x,a.y,a.w,a.h)) return true;
        }
      }
      return false;
    }

    // ===== ì•„ì´í…œ(í•˜íŠ¸) =====
    const items = []; // {type:'life', x,y, r}
    let itemTimer = 180; // ìµœì´ˆ ì•½ 3ì´ˆ í›„ ë“±ì¥

    function spawnLifeItem() {
      const r = 12;
      const y = groundY() - 80 - Math.random()*60; // ê³µì¤‘ì— ì‚´ì§
      items.push({ type:'life', x: W + 30, y, r });
    }

    function updateItems() {
      const speed = baseSpeed + Math.min(6, score/150);
      for (const it of items) it.x -= speed * 0.9; // ì¥ì• ë¬¼ë³´ë‹¤ ì‚´ì§ ëŠë¦¬ê²Œ
      for (let i=items.length-1;i>=0;i--){
        if (items[i].x + items[i].r < -40) items.splice(i,1);
      }
      if (itemTimer <= 0) {
        // í™•ë¥ ì ìœ¼ë¡œ ìƒì„±
        if (Math.random() < 0.45) spawnLifeItem();
        // ë‹¤ìŒ íƒ€ì´ë¨¸ (ì•½ 6~10ì´ˆ)
        itemTimer = 360 + Math.floor(Math.random()*240);
      } else itemTimer--;
    }

    function drawItems() {
      for (const it of items) {
        if (it.type === 'life') {
          ctx.font = "20px Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, emoji";
          ctx.fillText("â¤ï¸", it.x, it.y);
        }
      }
    }

    function pickupCheck() {
      const box = { x: pig.x-8, y: pig.y-24, w: 28, h: 26 };
      for (let i=items.length-1;i>=0;i--){
        const it = items[i];
        if (it.type === 'life') {
          const ix = it.x-10, iy = it.y-18, iw = 20, ih = 22; // ì´ëª¨ì§€ ëŒ€ëµ í¬ê¸°
          if (rectsOverlap(box.x,box.y,box.w,box.h, ix,iy,iw,ih)) {
            if (lives < maxLives) lives++;
            updateLivesHUD();
            items.splice(i,1);
          }
        }
      }
    }

    // ===== ë£¨í”„ & ì¶©ëŒ ì²˜ë¦¬(ë¬´ì /ì ë©¸ í¬í•¨) =====
    let rafId = null;

    function startGame(){
      cancelAnimationFrame(rafId);
      running = true; score = 0;
      lives = 3; updateLivesHUD();

      obstacles.length = 0; spawnTimer = 0; baseSpeed = 3;
      items.length = 0; itemTimer = 180;

      pig.y = groundY() - 20; pig.vy = 0; pig.onGround = true; pig.jumpCount = 0; pig.invUntil = 0; pig.blink = false;

      startScreen.style.display = "none";
      gameOverScreen.style.display = "none";
      hud.style.display = "flex";
      loop();
    }

    function endGame(){
      running = false;
      hud.style.display = "none";
      finalScore.textContent = score;
      gameOverScreen.style.display = "flex";
    }

    function takeHit() {
      const now = performance.now();
      if (now < pig.invUntil) return; // ë¬´ì ì´ë©´ ë¬´ì‹œ
      lives = Math.max(0, lives - 1);
      updateLivesHUD();
      if (lives <= 0) { endGame(); return; }
      // 1.2ì´ˆ ë¬´ì  + ì ë©¸
      pig.invUntil = now + 1200;
    }

    function loop(){
      if (!running) return;
      ctx.clearRect(0,0,W,H);

      // ë°”ë‹¥
      ctx.fillStyle = "#f0f0f0";
      ctx.fillRect(0, groundY(), W, 50);

      // ì¤‘ë ¥/ì í”„
      pig.vy += 0.7;
      pig.y += pig.vy;
      if (pig.y >= groundY() - 20) {
        pig.y = groundY() - 20;
        pig.vy = 0; pig.onGround = true; pig.jumpCount = 0;
      }

      // ì¥ì• ë¬¼/ì•„ì´í…œ ì—…ë°ì´íŠ¸ & ë Œë”
      updateObstacles();
      updateItems();
      drawObstacles();
      drawItems();

      // ìºë¦­í„°(ë¬´ì ì´ë©´ ê¹œë¹¡ì„)
      const now = performance.now();
      const invActive = now < pig.invUntil;
      let alpha = 1;
      if (invActive) {
        // 100ms ì£¼ê¸°ë¡œ ê¹œë¹¡ì„
        alpha = ((now / 100 | 0) % 2) ? 0.35 : 1;
      }
      ctx.fillStyle = "#333";
      drawEmojiFacingRight(EMOJI, pig.x, pig.y, alpha);

      // ì¶©ëŒ ì²´í¬
      if (!invActive && checkCollision()) {
        takeHit();
      }

      // ì•„ì´í…œ íšë“ ì²´í¬
      pickupCheck();

      // ì ìˆ˜
      score++;
      hudScore.textContent = score;

      rafId = requestAnimationFrame(loop);
    }

    // í˜ì´ì§€ ìˆ¨ê¹€ ì‹œ ë£¨í”„ ì •ë¦¬
    document.addEventListener("visibilitychange", () => {
      if (document.hidden && running) cancelAnimationFrame(rafId);
      else if (!document.hidden && running) rafId = requestAnimationFrame(loop);
    });

    // ìŠ¤í¬ë¡¤ ë°©ì§€
    document.addEventListener("touchmove", (e) => {
      if (e.target === canvas || e.target.closest("#gameWrap")) e.preventDefault();
    }, { passive: false });
  </script>
</body>
</html>