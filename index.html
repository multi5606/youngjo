<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
  <title>날아라 멀캠러</title>
  <!-- 파비콘: 주황색 동그라미 -->
  <link rel="icon" type="image/svg+xml"
        href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><circle cx="32" cy="32" r="28" fill="%23ff7a17"/></svg>'>
  <meta name="theme-color" content="#ffffff" />
  <style>
    :root{
      --bg:#ffffff; --panel:#ffffff; --text:#0e1220; --accent:#ff7a17;
      --muted:#6b7280; --line:#e9edf3; --shadow:rgba(0,0,0,0.06);
      --logo: clamp(56px, 8vw, 96px);
    }
    *{box-sizing:border-box}
    html,body{
      height:100%; margin:0; background:var(--bg); color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, "Noto Sans KR", "맑은 고딕", sans-serif;
      -webkit-tap-highlight-color: transparent;
    }
    body, button { touch-action: manipulation; user-select: none; -webkit-user-select: none; }
    #gameWrap{
      position:relative;width:100%;
      height:calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      padding-top:env(safe-area-inset-top); padding-bottom:env(safe-area-inset-bottom);
      overflow:hidden; background:var(--bg);
    }
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;background:#ffffff;}
    .mc-logo-img{
      position:absolute; left:12px; top: calc(env(safe-area-inset-top) + 10px);
      z-index:20; width:var(--logo); height:var(--logo); object-fit:contain; -webkit-user-drag:none; pointer-events:none;
    }
    /* HUD: 라이프/점수만 표시 */
    .cornerHUD{
      position:absolute; left:12px; top:calc(var(--logo) + 24px);
      z-index:8; display:flex; flex-direction:column; gap:6px;
      background:rgba(255,255,255,0.88); padding:8px 10px; border-radius:10px; border:1px solid var(--line);
      backdrop-filter: blur(4px); font-weight:700;
    }
    .lifeRow{ display:flex; align-items:center; gap:6px; }
    .heart{ font-size:18px; line-height:1; }
    .scoreLabel{ font-weight:800; }

    .soundToggle{
      position:absolute; right:12px; top: calc(env(safe-area-inset-top) + 10px);
      z-index:20; background:rgba(255,255,255,0.88); border:1px solid var(--line); border-radius:999px;
      padding:6px 12px; font-weight:800; display:inline-flex; align-items:center; gap:8px; backdrop-filter: blur(4px);
    }
    .soundToggle button{ background:none; border:none; font:inherit; cursor:pointer; }
    .soundToggle .icon{font-size:18px}

    .overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(255,255,255,0.75); padding:clamp(12px, 3vw, 24px); z-index:6;
      -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px);
    }
    .panel{
      width:min(760px,94vw); background:var(--panel); border:1px solid var(--line);
      border-radius:16px; padding:clamp(14px, 2.8vw, 22px); box-shadow:0 10px 24px var(--shadow);
    }
    .title{font-weight:800; font-size: clamp(20px, 5.2vw, 34px); line-height:1.2; margin:4px 0 8px;}
    .subtitle{color:var(--muted); margin:0 0 14px; font-size:clamp(12px, 3.4vw, 14px)}
    .btn{appearance:none; border:1px solid var(--line); background:#fff; color:#0b1020;
      padding:12px 16px; border-radius:12px; cursor:pointer; font-weight:800; transition:.15s;
      box-shadow:0 2px 6px var(--shadow); font-size:clamp(14px, 3.6vw, 16px);}
    .btn.primary{background:var(--accent); border-color:#ef6b05; color:#111;}
    .btn:active{transform: translateY(1px)}
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game" aria-label="게임 캔버스" role="img"></canvas>

    <img class="mc-logo-img" alt="multicampus"
         decoding="async" fetchpriority="high"
         src="https://api.multicampus.com/ssf/v1/resource/public/images/FILBS202506207041267"/>

    <div class="soundToggle"><span class="icon" id="soundIcon">🔊</span><button id="btnSound" aria-pressed="false">사운드 ON</button></div>

    <!-- HUD -->
    <div class="cornerHUD" id="hud" style="display:none">
      <div class="lifeRow" id="lifeRow" aria-label="남은 목숨"></div>
      <div class="scoreLabel">점수 <b id="hudScore">0</b></div>
    </div>

    <!-- Start Screen -->
    <div class="overlay" id="startScreen" aria-modal="true">
      <div class="panel">
        <div class="title">날아라 멀캠러!</div>
        <p class="subtitle">장애물 피해 멀리 달려보세요 🚀</p>
        <button class="btn primary" id="btnStart">게임 시작</button>
      </div>
    </div>

    <!-- Game Over -->
    <div class="overlay" id="gameOverScreen" style="display:none" aria-modal="true">
      <div class="panel">
        <div class="title">게임 종료</div>
        <div><span id="finalScore">0</span> 점</div>
        <button class="btn" id="btnRetry">다시 하기</button>
        <button class="btn" id="btnGoHome">처음으로</button>
      </div>
    </div>
  </div>

  <script>
    // ===== 기본 세팅 =====
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d", { alpha: true, desynchronized: true });
    let W=0, H=0, DPR=Math.min(window.devicePixelRatio||1, 2);

    function applyCanvasSize() {
      const cw = Math.floor(canvas.clientWidth);
      const ch = Math.floor(canvas.clientHeight);
      W = cw; H = ch;
      canvas.width  = Math.max(1, Math.floor(cw * DPR));
      canvas.height = Math.max(1, Math.floor(ch * DPR));
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      ctx.textBaseline = "alphabetic";
    }
    new ResizeObserver(applyCanvasSize).observe(canvas); applyCanvasSize();

    const groundY = () => H - 50;

    // ===== 게임 상태 =====
    let running=false, score=0;
    let lives=3, maxLives=5;
    const hud = document.getElementById("hud");
    const hudScore = document.getElementById("hudScore");
    const lifeRow = document.getElementById("lifeRow");
    const startScreen = document.getElementById("startScreen");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const finalScore = document.getElementById("finalScore");

    document.getElementById("btnStart").addEventListener("click", startGame, {passive:true});
    document.getElementById("btnRetry").addEventListener("click", startGame, {passive:true});
    document.getElementById("btnGoHome").addEventListener("click", ()=> {
      startScreen.style.display="flex"; gameOverScreen.style.display="none";
    }, {passive:true});

    // 사운드 토글(후속 확장용)
    const btnSound = document.getElementById("btnSound");
    const soundIcon = document.getElementById("soundIcon");
    let soundOn = true;
    btnSound.addEventListener("click", ()=>{
      soundOn = !soundOn;
      btnSound.textContent = soundOn ? "사운드 ON" : "사운드 OFF";
      btnSound.setAttribute("aria-pressed", String(soundOn));
      soundIcon.textContent = soundOn ? "🔊" : "🔇";
    }, {passive:true});

    // ===== 플레이어(이모지, 오른쪽 보게 반전) & 점프 =====
    const EMOJI = "🐖"; // 기본 좌향 -> 반전 렌더
    const EMOJI_FONT = "28px Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, emoji";
    const pig = { x: 100, y: 0, vy: 0, onGround: true, jumpCount: 0, maxJump: 2, invUntil: 0, blink: false };

    function drawEmojiFacingRight(text, x, y, alpha=1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.font = EMOJI_FONT;
      const w = Math.max(24, ctx.measureText(text).width);
      ctx.translate(x + w, 0);
      ctx.scale(-1, 1);
      ctx.fillText(text, 0, y);
      ctx.restore();
    }

    function updateLivesHUD() {
      lifeRow.innerHTML = "";
      for (let i=0;i<lives;i++){
        const span = document.createElement("span");
        span.className = "heart";
        span.textContent = "❤️";
        lifeRow.appendChild(span);
      }
      if (lives === 0) {
        const span = document.createElement("span");
        span.className = "heart";
        span.textContent = "🖤";
        lifeRow.appendChild(span);
      }
    }

    function jump(){
      if (!running) return;
      if (pig.jumpCount < pig.maxJump) {
        pig.vy = -12;
        pig.onGround = false;
        pig.jumpCount++;
      }
    }
    window.addEventListener("keydown", (e)=>{
      if (e.code === "Space" || e.code === "ArrowUp") { e.preventDefault(); jump(); }
    }, { passive:false });
    canvas.addEventListener("pointerdown", ()=> jump(), { passive:true });

    // ===== 장애물(랜덤 모양) =====
    const obstacles = [];
    let spawnTimer = 0;
    let baseSpeed = 3;

    // shape: 'rect' | 'circle' | 'tri'
    function spawnObstacle() {
      const shapeTypes = ["rect", "circle", "tri"];
      const shape = shapeTypes[(Math.random() * shapeTypes.length) | 0];

      // 크기 랜덤
      const sizeA = 24 + Math.random()*40; // 폭/지름/밑변 등
      const sizeB = 24 + Math.random()*40; // 높이(사각/삼각)
      const color = "#ff7a17";

      const yTop = groundY() - Math.max(sizeA, sizeB) - (shape==="circle" ? 0 : 0);

      obstacles.push({
        shape,
        x: W + 30,
        y: shape === "circle" ? groundY() - sizeA/2 - 2 : groundY() - sizeB, // 원은 중심 y 사용
        w: sizeA,
        h: sizeB,
        r: sizeA/2, // circle radius
        color
      });
    }

    function updateObstacles() {
      const speed = baseSpeed + Math.min(6, score/150);
      for (const o of obstacles) o.x -= speed;
      for (let i=obstacles.length-1;i>=0;i--){
        if (obstacles[i].x + (obstacles[i].w || obstacles[i].r*2) < -60) obstacles.splice(i,1);
      }
      if (spawnTimer <= 0) {
        spawnObstacle();
        spawnTimer = 50 + Math.random()*55; // 0.9~1.75초 정도
      } else spawnTimer--;
    }

    function drawObstacles() {
      ctx.lineWidth = 2;
      for (const o of obstacles) {
        ctx.fillStyle = o.color;
        ctx.strokeStyle = "#e35f00";
        if (o.shape === "rect") {
          ctx.fillRect(o.x, o.y, o.w, o.h);
          ctx.strokeRect(o.x, o.y, o.w, o.h);
        } else if (o.shape === "circle") {
          ctx.beginPath();
          ctx.arc(o.x, o.y, o.r, 0, Math.PI*2);
          ctx.fill(); ctx.stroke();
        } else if (o.shape === "tri") {
          const base = o.w, height = o.h;
          ctx.beginPath();
          // 밑변은 바닥과 평행, 꼭짓점 위
          const x1 = o.x, x2 = o.x + base, x3 = o.x + base/2;
          const yBase = groundY();
          ctx.moveTo(x1, yBase);
          ctx.lineTo(x2, yBase);
          ctx.lineTo(x3, yBase - height);
          ctx.closePath();
          ctx.fill(); ctx.stroke();
          // tri의 충돌용 AABB 보정용 값 저장
          o._aabb = { x: Math.min(x1,x2,x3), y: yBase - height, w: base, h: height };
        }
      }
    }

    function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    function checkCollision() {
      // 캐릭터 히트박스(이모지 주변 사각형)
      const box = { x: pig.x-8, y: pig.y-24, w: 28, h: 26 };

      for (const o of obstacles) {
        if (o.shape === "rect") {
          if (rectsOverlap(box.x,box.y,box.w,box.h, o.x,o.y,o.w,o.h)) return true;
        } else if (o.shape === "circle") {
          // 원-사각 충돌
          const nx = Math.max(o.x - o.r, Math.min(box.x + box.w, o.x + o.r));
          const ny = Math.max(o.y - o.r, Math.min(box.y + box.h, o.y + o.r));
          const dx = nx - o.x, dy = ny - o.y;
          if (dx*dx + dy*dy <= o.r*o.r) return true;
        } else if (o.shape === "tri") {
          const a = o._aabb || { x:o.x, y:o.y, w:o.w, h:o.h };
          if (rectsOverlap(box.x,box.y,box.w,box.h, a.x,a.y,a.w,a.h)) return true;
        }
      }
      return false;
    }

    // ===== 아이템(하트) =====
    const items = []; // {type:'life', x,y, r}
    let itemTimer = 180; // 최초 약 3초 후 등장

    function spawnLifeItem() {
      const r = 12;
      const y = groundY() - 80 - Math.random()*60; // 공중에 살짝
      items.push({ type:'life', x: W + 30, y, r });
    }

    function updateItems() {
      const speed = baseSpeed + Math.min(6, score/150);
      for (const it of items) it.x -= speed * 0.9; // 장애물보다 살짝 느리게
      for (let i=items.length-1;i>=0;i--){
        if (items[i].x + items[i].r < -40) items.splice(i,1);
      }
      if (itemTimer <= 0) {
        // 확률적으로 생성
        if (Math.random() < 0.45) spawnLifeItem();
        // 다음 타이머 (약 6~10초)
        itemTimer = 360 + Math.floor(Math.random()*240);
      } else itemTimer--;
    }

    function drawItems() {
      for (const it of items) {
        if (it.type === 'life') {
          ctx.font = "20px Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, emoji";
          ctx.fillText("❤️", it.x, it.y);
        }
      }
    }

    function pickupCheck() {
      const box = { x: pig.x-8, y: pig.y-24, w: 28, h: 26 };
      for (let i=items.length-1;i>=0;i--){
        const it = items[i];
        if (it.type === 'life') {
          const ix = it.x-10, iy = it.y-18, iw = 20, ih = 22; // 이모지 대략 크기
          if (rectsOverlap(box.x,box.y,box.w,box.h, ix,iy,iw,ih)) {
            if (lives < maxLives) lives++;
            updateLivesHUD();
            items.splice(i,1);
          }
        }
      }
    }

    // ===== 루프 & 충돌 처리(무적/점멸 포함) =====
    let rafId = null;

    function startGame(){
      cancelAnimationFrame(rafId);
      running = true; score = 0;
      lives = 3; updateLivesHUD();

      obstacles.length = 0; spawnTimer = 0; baseSpeed = 3;
      items.length = 0; itemTimer = 180;

      pig.y = groundY() - 20; pig.vy = 0; pig.onGround = true; pig.jumpCount = 0; pig.invUntil = 0; pig.blink = false;

      startScreen.style.display = "none";
      gameOverScreen.style.display = "none";
      hud.style.display = "flex";
      loop();
    }

    function endGame(){
      running = false;
      hud.style.display = "none";
      finalScore.textContent = score;
      gameOverScreen.style.display = "flex";
    }

    function takeHit() {
      const now = performance.now();
      if (now < pig.invUntil) return; // 무적이면 무시
      lives = Math.max(0, lives - 1);
      updateLivesHUD();
      if (lives <= 0) { endGame(); return; }
      // 1.2초 무적 + 점멸
      pig.invUntil = now + 1200;
    }

    function loop(){
      if (!running) return;
      ctx.clearRect(0,0,W,H);

      // 바닥
      ctx.fillStyle = "#f0f0f0";
      ctx.fillRect(0, groundY(), W, 50);

      // 중력/점프
      pig.vy += 0.7;
      pig.y += pig.vy;
      if (pig.y >= groundY() - 20) {
        pig.y = groundY() - 20;
        pig.vy = 0; pig.onGround = true; pig.jumpCount = 0;
      }

      // 장애물/아이템 업데이트 & 렌더
      updateObstacles();
      updateItems();
      drawObstacles();
      drawItems();

      // 캐릭터(무적이면 깜빡임)
      const now = performance.now();
      const invActive = now < pig.invUntil;
      let alpha = 1;
      if (invActive) {
        // 100ms 주기로 깜빡임
        alpha = ((now / 100 | 0) % 2) ? 0.35 : 1;
      }
      ctx.fillStyle = "#333";
      drawEmojiFacingRight(EMOJI, pig.x, pig.y, alpha);

      // 충돌 체크
      if (!invActive && checkCollision()) {
        takeHit();
      }

      // 아이템 획득 체크
      pickupCheck();

      // 점수
      score++;
      hudScore.textContent = score;

      rafId = requestAnimationFrame(loop);
    }

    // 페이지 숨김 시 루프 정리
    document.addEventListener("visibilitychange", () => {
      if (document.hidden && running) cancelAnimationFrame(rafId);
      else if (!document.hidden && running) rafId = requestAnimationFrame(loop);
    });

    // 스크롤 방지
    document.addEventListener("touchmove", (e) => {
      if (e.target === canvas || e.target.closest("#gameWrap")) e.preventDefault();
    }, { passive: false });
  </script>
</body>
</html>